---
title: 邮件解析
date: 2018-11-15 11:22:07
tags:
---
![猫咪老师](/images/页面图片/17.jpg)
<!--more-->
解析协议为imap的邮件,解析确定主题，将接收到的邮件附件保存 并解析 进行操作
## 配置文件 配置邮箱信息
```
# 邮箱配置
mail.store.protocol=imap /
mail.imap.host=imap.exmail.qq.com 
mail.username=xxxxx
mail.password=xxxxx

# 自定义邮件附件存储目录
custom.mail.attachments.save.path = d:\\mailtmp\\
custom.mail.attachments.save.prefix = GQHL
custom.mail.match.key = \u5408\u683c\u8bc1\u91ca\u653e
```
## 将邮件解析逻辑抽取为工具类
```
public class MailUtils {

    /**
     * 使用imap协议获取未读邮件数
     * 测试IMAP协议
     * @author hefan
     * @date 2018/11/9 15:37
     */
    public static void readByImap() throws Exception {
        String user = "xxxx";// 邮箱的用户名
        String password = "xxx"; // 邮箱的密码

        Properties prop = System.getProperties();
        prop.put("mail.store.protocol", "imap");
        prop.put("mail.imap.host", "imap.exmail.qq.com");

        Session session = Session.getInstance(prop);

        int total = 0;
        IMAPStore store = (IMAPStore) session.getStore("imap"); // 使用imap会话机制，连接服务器
        store.connect(user, password);
        IMAPFolder folder = (IMAPFolder) store.getFolder("INBOX"); // 收件箱
        folder.open(Folder.READ_WRITE);
        // 获取总邮件数
        total = folder.getMessageCount();
        System.out.println("-----------------共有邮件：" + total + " 封--------------");
        // 得到收件箱文件夹信息，获取邮件列表
        System.out.println("未读邮件数：" + folder.getUnreadMessageCount());
        Message[] messages = folder.getMessages();
        int messageNumber = 0;
        for (Message message : messages) {
            System.out.println("发送时间：" + message.getSentDate());
            System.out.println("主题：" + message.getSubject());
            System.out.println("内容：" + message.getContent());
            Flags flags = message.getFlags();
            if (flags.contains(Flags.Flag.SEEN))
                System.out.println("这是一封已读邮件");
            else {
                System.out.println("未读邮件");
            }
            System.out
                    .println("========================================================");
            System.out
                    .println("========================================================");
            boolean isContainerAttachment = isContainAttachment(message);
            System.out.println("邮件大小：" + message.getSize() / 1024 + "kb");
            System.out.println("是否包含附件：" + isContainerAttachment);
            if (isContainerAttachment) {
                saveAttachment(message, "d:\\mailtmp\\" + message.getSubject() + "_"); //保存附件
            }
            //每封邮件都有一个MessageNumber，可以通过邮件的MessageNumber在收件箱里面取得该邮件
            messageNumber = message.getMessageNumber();
        }
        Message message = folder.getMessage(messageNumber);
        System.out.println(message.getContent() + message.getContentType());
        // 释放资源
        if (folder != null) {
            folder.close(true);
        }

        if (store != null) {
            store.close();
        }
    }


    /**
     * pop3接收邮件
     * 测试pop3协议
     * @author hefan
     * @date 2018/11/10 14:18
     */
    public static void readByPop3() throws Exception {
        Properties props = new Properties();
        props.setProperty("mail.store.protocol", "pop3");       // 协议
        props.setProperty("mail.pop3.port", "110");             // 端口
        props.setProperty("mail.pop3.host", "pop.163.com");    // pop3服务器

        // 创建Session实例对象
        Session session = Session.getInstance(props);
        Store store = session.getStore("pop3");
        store.connect("xxxxx", "xxxxx");

        // 获得收件箱
        IMAPFolder folder = (IMAPFolder) store.getFolder("INBOX"); // 收件箱
        /* Folder.READ_ONLY：只读权限
         * Folder.READ_WRITE：可读可写（可以修改邮件的状态）
         */
        folder.open(Folder.READ_WRITE); //打开收件箱

        // 由于POP3协议无法获知邮件的状态,所以getUnreadMessageCount得到的是收件箱的邮件总数
        System.out.println("未读邮件数: " + folder.getUnreadMessageCount());

        // 由于POP3协议无法获知邮件的状态,所以下面得到的结果始终都是为0
        System.out.println("删除邮件数: " + folder.getDeletedMessageCount());
        System.out.println("新邮件: " + folder.getNewMessageCount());

        // 获得收件箱中的邮件总数
        System.out.println("邮件总数: " + folder.getMessageCount());

        // 得到收件箱中的所有邮件,并解析
        Message[] messages = folder.getMessages();
        parseMessage(messages);

        //释放资源
        folder.close(true);
        store.close();
    }

    /**
     * 解析邮件
     *
     * @param messages 要解析的邮件列表
     */
    public static void parseMessage(Message... messages) throws MessagingException, IOException {
        if (!(messages == null || messages.length < 1)) {
            //throw new MessagingException("未找到要解析的邮件!");
            return;
        }
        // 解析所有邮件
        for (int i = 0, count = messages.length; i < count; i++) {
            MimeMessage msg = (MimeMessage) messages[i];
            System.out.println("------------------解析第" + msg.getMessageNumber() + "封邮件-------------------- ");
            System.out.println("主题: " + getSubject(msg));
            System.out.println("发件人: " + getFrom(msg));
            System.out.println("收件人：" + getReceiveAddress(msg, null));
            System.out.println("发送时间：" + getSentDate(msg, null));
            System.out.println("是否已读：" + isSeen(msg));
            System.out.println("邮件优先级：" + getPriority(msg));
            System.out.println("是否需要回执：" + isReplySign(msg));
            System.out.println("邮件大小：" + msg.getSize() * 1024 + "kb");
            boolean isContainerAttachment = isContainAttachment(msg);
            System.out.println("是否包含附件：" + isContainerAttachment);
            if (isContainerAttachment) {
                saveAttachment(msg, "d:\\mailtmp\\" + msg.getSubject() + "_"); //保存附件
            }
            StringBuffer content = new StringBuffer(30);
            getMailTextContent(msg, content);
            System.out.println("邮件正文：" + (content.length() > 100 ? content.substring(0, 100) + "..." : content));
            System.out.println("------------------第" + msg.getMessageNumber() + "封邮件解析结束-------------------- ");
            //设置删除标记
            msg.setFlag(Flags.Flag.DELETED, true);
            System.out.println("------------------第" + msg.getMessageNumber() + "封邮件标记删除-------------------- ");
            System.out.println();
        }
    }

    /**
     * 获得邮件主题
     *
     * @param msg 邮件内容
     * @return 解码后的邮件主题
     */
    public static String getSubject(MimeMessage msg) throws UnsupportedEncodingException, MessagingException {
        return MimeUtility.decodeText(msg.getSubject());
    }

    /**
     * 获得邮件发件人
     *
     * @param msg 邮件内容
     * @return 姓名 <Email地址>
     * @throws MessagingException
     * @throws UnsupportedEncodingException
     */
    public static String getFrom(MimeMessage msg) throws MessagingException, UnsupportedEncodingException {
        String from = "";
        Address[] froms = msg.getFrom();
        if (froms.length < 1) {
            throw new MessagingException("没有发件人!");
        }
        InternetAddress address = (InternetAddress) froms[0];
        String person = address.getPersonal();
        if (person != null) {
            person = MimeUtility.decodeText(person) + " ";
        } else {
            person = "";
        }
        from = person + "<" + address.getAddress() + ">";
        return from;
    }

    /**
     * 根据收件人类型，获取邮件收件人、抄送和密送地址。如果收件人类型为空，则获得所有的收件人
     * <p>Message.RecipientType.TO  收件人</p>
     * <p>Message.RecipientType.CC  抄送</p>
     * <p>Message.RecipientType.BCC 密送</p>
     *
     * @param msg  邮件内容
     * @param type 收件人类型
     * @return 收件人1 <邮件地址1>, 收件人2 <邮件地址2>, ...
     * @throws MessagingException
     */
    public static String getReceiveAddress(MimeMessage msg, Message.RecipientType type) throws MessagingException {
        StringBuffer receiveAddress = new StringBuffer();
        Address[] addresss = null;
        if (type == null) {
            addresss = msg.getAllRecipients();
        } else {
            addresss = msg.getRecipients(type);
        }

        if (addresss == null || addresss.length < 1)
            throw new MessagingException("没有收件人!");
        for (Address address : addresss) {
            InternetAddress internetAddress = (InternetAddress) address;
            receiveAddress.append(internetAddress.toUnicodeString()).append(",");
        }

        receiveAddress.deleteCharAt(receiveAddress.length() - 1); //删除最后一个逗号

        return receiveAddress.toString();
    }

    /**
     * 获得邮件发送时间
     *
     * @param msg 邮件内容
     * @return yyyy年mm月dd日 星期X HH:mm:ss
     * @throws MessagingException
     */
    public static String getSentDate(MimeMessage msg, String pattern) throws MessagingException {
        Date receivedDate = msg.getSentDate();
        if (receivedDate == null) {
            return "";
        }
        if (pattern == null || "".equals(pattern)) {
            pattern = "yyyy年MM月dd日 E HH:mm:ss ";
        }
        return new SimpleDateFormat(pattern).format(receivedDate);
    }

    /**
     * 判断邮件中是否包含附件
     *
     * @param part 邮件内容
     * @return 邮件中存在附件返回true，不存在返回false
     * @throws MessagingException
     * @throws IOException
     */
    public static boolean isContainAttachment(Part part) throws MessagingException, IOException {
        boolean flag = false;
        if (part.isMimeType("multipart/*")) {
            MimeMultipart multipart = (MimeMultipart) part.getContent();
            int partCount = multipart.getCount();
            for (int i = 0; i < partCount; i++) {
                BodyPart bodyPart = multipart.getBodyPart(i);
                String disp = bodyPart.getDisposition();
                if (disp != null && (disp.equalsIgnoreCase(Part.ATTACHMENT) || disp.equalsIgnoreCase(Part.INLINE))) {
                    flag = true;
                } else if (bodyPart.isMimeType("multipart/*")) {
                    flag = isContainAttachment(bodyPart);
                } else {
                    String contentType = bodyPart.getContentType();
                    if (contentType.indexOf("application") != -1) {
                        flag = true;
                    }

                    if (contentType.indexOf("name") != -1) {
                        flag = true;
                    }
                }

                if (flag) {
                    break;
                }
            }
        } else if (part.isMimeType("message/rfc822")) {
            flag = isContainAttachment((Part) part.getContent());
        }
        return flag;
    }

    /**
     * 判断邮件是否已读
     *
     * @param msg 邮件内容
     * @return 如果邮件已读返回true, 否则返回false
     * @throws MessagingException
     */
    public static boolean isSeen(MimeMessage msg) throws MessagingException {
        return msg.getFlags().contains(Flags.Flag.SEEN);
    }

    /**
     * 判断邮件是否需要阅读回执
     *
     * @param msg 邮件内容
     * @return 需要回执返回true, 否则返回false
     * @throws MessagingException
     */
    public static boolean isReplySign(MimeMessage msg) throws MessagingException {
        boolean replySign = false;
        String[] headers = msg.getHeader("Disposition-Notification-To");
        if (headers != null) {
            replySign = true;
        }
        return replySign;
    }

    /**
     * 获得邮件的优先级
     *
     * @param msg 邮件内容
     * @return 1(High):紧急  3:普通(Normal)  5:低(Low)
     * @throws MessagingException
     */
    public static String getPriority(MimeMessage msg) throws MessagingException {
        String priority = "普通";
        String[] headers = msg.getHeader("X-Priority");
        if (headers != null) {
            String headerPriority = headers[0];
            if (headerPriority.indexOf("1") != -1 || headerPriority.indexOf("High") != -1) {
                priority = "紧急";
            } else if (headerPriority.indexOf("5") != -1 || headerPriority.indexOf("Low") != -1) {
                priority = "低";
            } else {
                priority = "普通";
            }
        }
        return priority;
    }

    /**
     * 获得邮件文本内容
     *
     * @param part    邮件体
     * @param content 存储邮件文本内容的字符串
     * @throws MessagingException
     * @throws IOException
     */
    public static void getMailTextContent(Part part, StringBuffer content) throws MessagingException, IOException {
        //如果是文本类型的附件，通过getContent方法可以取到文本内容，但这不是我们需要的结果，所以在这里要做判断
        boolean isContainTextAttach = part.getContentType().indexOf("name") > 0;
        if (part.isMimeType("text/*") && !isContainTextAttach) {
            content.append(part.getContent().toString());
        } else if (part.isMimeType("message/rfc822")) {
            getMailTextContent((Part) part.getContent(), content);
        } else if (part.isMimeType("multipart/*")) {
            Multipart multipart = (Multipart) part.getContent();
            int partCount = multipart.getCount();
            for (int i = 0; i < partCount; i++) {
                BodyPart bodyPart = multipart.getBodyPart(i);
                getMailTextContent(bodyPart, content);
            }
        }
    }

//    @Deprecated
//    public static AttachmentDetail saveAttachment(Part part, String destDir, String matchKey,
//                                                  String savePrefix, Class clazz) throws Exception {
//        AttachmentDetail detail = null;
//        if (part.isMimeType("multipart/*")) {
//            //复杂体邮件
//            Multipart multipart = (Multipart) part.getContent();
//            //复杂体邮件包含多个邮件体
//            int partCount = multipart.getCount();
//            for (int i = 0; i < partCount; i++) {
//                //获得复杂体邮件中其中一个邮件体
//                BodyPart bodyPart = multipart.getBodyPart(i);
//                //某一个邮件体也有可能是由多个邮件体组成的复杂体
//                String disp = bodyPart.getDisposition();
//                if (disp != null && (disp.equalsIgnoreCase(Part.ATTACHMENT)
//                        || disp.equalsIgnoreCase(Part.INLINE))) {
//                    // 先解析文件后保存excel
//                    List data = ImportExcel.getInstance().
//                            getDataByExcelModel(bodyPart.getInputStream(),
//                                    decodeText(bodyPart.getFileName()), clazz);
//                    String saveName = generatorName(savePrefix);
//                    saveFile(bodyPart.getInputStream(), destDir, generatorName(saveName));
//                    return detail = new AttachmentDetail(decodeText(bodyPart.getFileName()), saveName, data);
//                } else if (bodyPart.isMimeType("multipart/*")) {
//                    saveAttachment(bodyPart, destDir,
//                            matchKey, savePrefix, clazz);
//                } else {
//                    String contentType = bodyPart.getContentType();
//                    if (contentType.indexOf("name") != -1
//                            || contentType.indexOf("application") != -1) {
//                        // 先解析文件后保存excel
//                        List data = ImportExcel.getInstance().
//                                getDataByExcelModel(bodyPart.getInputStream(),
//                                        decodeText(bodyPart.getFileName()), clazz);
//                        String saveName = generatorName(savePrefix);
//                        saveFile(bodyPart.getInputStream(), destDir, generatorName(saveName));
//                        return detail = new AttachmentDetail(decodeText(bodyPart.getFileName()), saveName, data);
//                    }
//                }
//            }
//        } else if (part.isMimeType("message/rfc822")) {
//            saveAttachment((Part) part.getContent(), destDir,
//                    matchKey, savePrefix, clazz);
//        }
//        return detail;
//    }

    /**
     * 保存附件
     *
     * @param part       邮件中多个组合体中的其中一个组合体
     * @param destDir    附件保存目录
     * @param matchKey   匹配关键字
     * @param savePrefix 保存文件名前缀
     * @throws MessagingException
     * @throws IOException
     */
    public static AttachmentDetail saveAttachment(Part part, String destDir, String matchKey,
                                                  String savePrefix, Class clazz) throws Exception {
        if (part.isMimeType("message/rfc822")) {
            saveAttachment((Part) part.getContent(),
                    destDir, matchKey, savePrefix, clazz);
        }
        // 复杂体邮件
        Multipart multipart = (Multipart) part.getContent();
        // 复杂体邮件包含多个邮件体
        InputStream is = null;
        String sourceName = null;
        String disp = null;
        BodyPart bodyPart = null;
        // 若有多个附件，仅筛选符合条件的第一个
        // 判断是否含有附件格式为excel，并且名称满足条件要求
        for (int i = 0; i < multipart.getCount(); i++) {
            // 获得复杂体邮件中其中一个邮件体
            bodyPart = multipart.getBodyPart(i);
            if (bodyPart.isMimeType("multipart/*")) {
                saveAttachment(bodyPart, destDir,
                        matchKey, savePrefix, clazz);
            }
            // 某一个邮件体也有可能是由多个邮件体组成的复杂体
            disp = bodyPart.getDisposition();
            sourceName = decodeText(bodyPart.getFileName());
            // 若附件格式不为excel，或者文件名不是指定格式，则查找一下
            if(StringUtils.isBlank(sourceName)
                    || !sourceName.contains(matchKey)
                    || ImportExcel.isNotExcelFile(sourceName)){
                continue;
            }
            is = bodyPart.getInputStream();
            if (StringUtils.isBlank(disp) || (!Part.ATTACHMENT.equalsIgnoreCase(disp)
                    && !Part.INLINE.equalsIgnoreCase(disp))){
                String contentType = bodyPart.getContentType();
                if (contentType.indexOf("name") == -1
                        && contentType.indexOf("application") == -1) {
                    continue;
                }
            }
            // 先解析文件后保存excel
            List data = ImportExcel.getInstance().
                    getDataByExcelModel(is, sourceName, clazz);
            String saveName = generatorName(savePrefix);
            saveFile(is, destDir, generatorName(saveName));
            return new AttachmentDetail(sourceName, saveName, data);
        }
        return null;
    }

    /**
     * 上传附件生成唯一名称
     * 生成规则，前缀 + msgNumber + yyyyMMddHHmmss
     * @date 2018/11/10 15:51
     */
    public static String generatorName(String filePrefix) {
        String dateStr = DateTimeUtils.format(new Date(),
                DateTimeUtils.YEAR_MONTH_DAY_HOUR_MINUTE_SECOND_SIMPLE);
        return filePrefix + dateStr;
    }


    /**
     * 保存附件
     *
     * @param part    邮件中多个组合体中的其中一个组合体
     * @param destDir 附件保存目录
     * @throws MessagingException
     * @throws IOException
     */
    public static void saveAttachment(Part part, String destDir)
            throws MessagingException, IOException {
        if (part.isMimeType("multipart/*")) {
            //复杂体邮件
            Multipart multipart = (Multipart) part.getContent();
            //复杂体邮件包含多个邮件体
            int partCount = multipart.getCount();
            for (int i = 0; i < partCount; i++) {
                //获得复杂体邮件中其中一个邮件体
                BodyPart bodyPart = multipart.getBodyPart(i);
                //某一个邮件体也有可能是由多个邮件体组成的复杂体
                String disp = bodyPart.getDisposition();
                if (disp != null && (disp.equalsIgnoreCase(Part.ATTACHMENT)
                        || disp.equalsIgnoreCase(Part.INLINE))) {
                    //TODO 修改存储文件名
                    saveFile(bodyPart.getInputStream(), destDir,
                            decodeText(bodyPart.getFileName()));
                } else if (bodyPart.isMimeType("multipart/*")) {
                    saveAttachment(bodyPart, destDir);
                } else {
                    String contentType = bodyPart.getContentType();
                    if (contentType.indexOf("name") != -1
                            || contentType.indexOf("application") != -1) {
                        saveFile(bodyPart.getInputStream(), destDir,
                                decodeText(bodyPart.getFileName()));
                    }
                }
            }
        } else if (part.isMimeType("message/rfc822")) {
            saveAttachment((Part) part.getContent(), destDir);
        }
    }

    /**
     * 读取输入流中的数据保存至指定目录
     *
     * @param is       输入流
     * @param fileName 文件名
     * @param destDir  文件存储目录
     * @throws FileNotFoundException
     * @throws IOException
     */
    private static void saveFile(InputStream is, String destDir, String fileName)
            throws IOException {
        BufferedInputStream bis = new BufferedInputStream(is);
        BufferedOutputStream bos = new BufferedOutputStream(
                new FileOutputStream(new File(destDir + fileName)));
        int len = -1;
        while ((len = bis.read()) != -1) {
            bos.write(len);
            bos.flush();
        }
        bos.close();
        bis.close();
    }

    /**
     * 文本解码
     *
     * @param encodeText 解码MimeUtility.encodeText(String text)方法编码后的文本
     * @return 解码后的文本
     * @throws UnsupportedEncodingException
     */
    public static String decodeText(String encodeText) throws UnsupportedEncodingException {
        if (encodeText == null || "".equals(encodeText)) {
            return "";
        } else {
            return MimeUtility.decodeText(encodeText);
        }
    }

}
```
## 邮箱监控工具
```
@Configuration
public class MailMonitor {

    public static final Logger logger = LoggerFactory.getLogger(MailMonitor.class);

    /**
     * 邮件配置文件
     */
    private Properties EMAIL_PROP = System.getProperties();

    /**
     * 收件箱名
     * @date 2018/11/9 13:57
     */
    private static final String FOLDER_NAME = "INBOX";

    /**
     * 协议
     */
    @Value("${mail.store.protocol}")
    private String protocol;

    /**
     * 服务器地址
     */
    @Value("${mail.imap.host}")
    private String host;

    /**
     * 用户名
     */
    @Value("${mail.username}")
    private String username;

    /**
     * 密码
     */
    @Value("${mail.password}")
    private String password;

    /**
     * session
     * @date 2018/11/9 10:47
     */
    private Session session;

    /**
     * store
     * @date 2018/11/9 10:47
     */
    private IMAPStore store;

    public void initProp(){
        EMAIL_PROP.put("mail.store.protocol", protocol);
        EMAIL_PROP.put("mail.imap.host", host);
    }

    /**
     * 使用imap会话机制，连接服务器
     * @date 2018/11/9 10:51
     */
    @PostConstruct
    public void init() throws MessagingException {
        initProp();
        session = Session.getInstance(EMAIL_PROP);
        store = (IMAPStore) session.getStore(protocol);
        store.connect(username, password);
    }

    /**
     * 获取并开启folder
     * @date 2018/11/9 15:17
     */
    public IMAPFolder getAndOpen() throws MessagingException {
        IMAPFolder folder = null;
        try {
            folder = (IMAPFolder) store.getFolder(FOLDER_NAME);
            folder.open(Folder.READ_WRITE);
        } catch (MessagingException e) {
            logger.error("获取开启收件箱异常！", e);
            throw e;
        }
        return folder;
    }

    /**
     * 接收邮件数据
     * @date 2018/11/9 15:16
     */
    public Message[] receive() throws MessagingException {
        IMAPFolder folder = getAndOpen();
        Message[] message = null;
        try {
            // 获取总邮件数
            int total = folder.getMessageCount();
            logger.info("-----------------共有邮件：" + total + " 封--------------");
            logger.info("-----------------未读邮件数：" + folder.getUnreadMessageCount() + "--------------");
            message = folder.getMessages();
        } catch (Exception e){
            logger.error("接收message异常！", e);
        } finally {
            if(null != folder){
                try {
                    folder.close(true);
                } catch (MessagingException e) {
                    logger.error("关闭folder异常！", e);
                }
            }
        }
        return message;
    }

    /**
     * 根据消息数获取邮件
     * @date 2018/11/9 15:22
     * @param msgNumber
     * @return
     */
    public Message get(Integer msgNumber) {
        Message message = null;
        try {
            getAndOpen().getMessage(msgNumber);
        } catch (MessagingException e){
            logger.error("MessagingException!", e);
        }
        return message;
    }

    @PreDestroy
    public void shutdown() {
        logger.info("Stopping store!");
        try {
            store.close();
        } catch (MessagingException e) {
            logger.error("Stop Store error!", e);
        } finally {
            store = null;
            session = null;
        }
        logger.info("Store stopped!");
    }

}
```
## 附件内容类
```
@XlsRecord(startRow = 1, startCol = 0, cells = {
        @XlsCell(objFieldName = "CUSTODIAN_CODE", objFieldType = XlsDataType.STRING, order = 0),
        @XlsCell(objFieldName = "Custodian_Name", objFieldType = XlsDataType.STRING, order = 1),
        @XlsCell(objFieldName = "Dealer_Code", objFieldType = XlsDataType.STRING, order = 2),
        @XlsCell(objFieldName = "Dealer_Name", objFieldType = XlsDataType.STRING, order = 3),
        @XlsCell(objFieldName = "Distributor_Code", objFieldType = XlsDataType.STRING, order = 4),
        @XlsCell(objFieldName = "Make", objFieldType = XlsDataType.STRING, order = 5),
        @XlsCell(objFieldName = "VIN_No", objFieldType = XlsDataType.STRING, order = 6),
        @XlsCell(objFieldName = "Asset_Model", objFieldType = XlsDataType.STRING, order = 7),
        @XlsCell(objFieldName = "QC_Number", objFieldType = XlsDataType.STRING, order = 8),
        @XlsCell(objFieldName = "QC_Check", objFieldType = XlsDataType.STRING, order = 9),
        @XlsCell(objFieldName = "IMPORT_CERT_CHECK", objFieldType = XlsDataType.STRING, order = 10),
        @XlsCell(objFieldName = "CHECKLIST_CHECK", objFieldType = XlsDataType.STRING, order = 11),
        @XlsCell(objFieldName = "C_CERTIFICATE_CHECK", objFieldType = XlsDataType.STRING, order = 12),
        @XlsCell(objFieldName = "Remarks", objFieldType = XlsDataType.STRING, order = 13)
})
public class ReleaseMail {

    private String CUSTODIAN_CODE;

    private String Custodian_Name;

    private String Dealer_Code;

    private String Dealer_Name;

    private String Distributor_Code;

    private String Make;

    /**
     * 车架号
     * @author hefan
     * @date 2018/11/10 10:19
     */
    private String VIN_No;

    private String Asset_Model;

    private String QC_Number;

    private String QC_Check;

    private String IMPORT_CERT_CHECK;

    private String CHECKLIST_CHECK;

    private String C_CERTIFICATE_CHECK;

    private String Remarks;

    /**
     * 转换对象
     * @author hefan
     * @date 2018/11/10 15:32
     */
    public Paramer convertToParameter(){
        return new Paramer(this.VIN_No, (byte)0, true);
    }

    public String getCUSTODIAN_CODE() {
        return CUSTODIAN_CODE;
    }

    public void setCUSTODIAN_CODE(String CUSTODIAN_CODE) {
        this.CUSTODIAN_CODE = CUSTODIAN_CODE;
    }

    public String getCustodian_Name() {
        return Custodian_Name;
    }

    public void setCustodian_Name(String custodian_Name) {
        Custodian_Name = custodian_Name;
    }

    public String getDealer_Code() {
        return Dealer_Code;
    }

    public void setDealer_Code(String dealer_Code) {
        Dealer_Code = dealer_Code;
    }

    public String getDealer_Name() {
        return Dealer_Name;
    }

    public void setDealer_Name(String dealer_Name) {
        Dealer_Name = dealer_Name;
    }

    public String getDistributor_Code() {
        return Distributor_Code;
    }

    public void setDistributor_Code(String distributor_Code) {
        Distributor_Code = distributor_Code;
    }

    public String getMake() {
        return Make;
    }

    public void setMake(String make) {
        Make = make;
    }

    public String getVIN_No() {
        return VIN_No;
    }

    public void setVIN_No(String VIN_No) {
        this.VIN_No = VIN_No;
    }

    public String getAsset_Model() {
        return Asset_Model;
    }

    public void setAsset_Model(String asset_Model) {
        Asset_Model = asset_Model;
    }

    public String getQC_Number() {
        return QC_Number;
    }

    public void setQC_Number(String QC_Number) {
        this.QC_Number = QC_Number;
    }

    public String getQC_Check() {
        return QC_Check;
    }

    public void setQC_Check(String QC_Check) {
        this.QC_Check = QC_Check;
    }

    public String getIMPORT_CERT_CHECK() {
        return IMPORT_CERT_CHECK;
    }

    public void setIMPORT_CERT_CHECK(String IMPORT_CERT_CHECK) {
        this.IMPORT_CERT_CHECK = IMPORT_CERT_CHECK;
    }

    public String getCHECKLIST_CHECK() {
        return CHECKLIST_CHECK;
    }

    public void setCHECKLIST_CHECK(String CHECKLIST_CHECK) {
        this.CHECKLIST_CHECK = CHECKLIST_CHECK;
    }

    public String getC_CERTIFICATE_CHECK() {
        return C_CERTIFICATE_CHECK;
    }

    public void setC_CERTIFICATE_CHECK(String c_CERTIFICATE_CHECK) {
        C_CERTIFICATE_CHECK = c_CERTIFICATE_CHECK;
    }

    public String getRemarks() {
        return Remarks;
    }

    public void setRemarks(String remarks) {
        Remarks = remarks;
    }
}
```
## 附件详情类
```
public class AttachmentDetail<T> {

    /**
     * 源名称
     */
    private String sourceName;

    /**
     * 保存名称
     */
    private String saveName;

    /**
     * 解析后附件内容
     */
    private List<T> data;

    public AttachmentDetail() {
    }

    /**
     * 构造附件详情
     * @author hefan
     * @date 2018/11/10 15:45
     * @param sourceName    源名称
     * @param saveName      保存名称
     * @param data          解析附件数据
     */
    public AttachmentDetail(String sourceName, String saveName, List<T> data) {
        this.sourceName = sourceName;
        this.saveName = saveName;
        this.data = data;
    }

    public String getSourceName() {
        return sourceName;
    }

    public void setSourceName(String sourceName) {
        this.sourceName = sourceName;
    }

    public String getSaveName() {
        return saveName;
    }

    public void setSaveName(String saveName) {
        this.saveName = saveName;
    }

    public List<T> getData() {
        return data;
    }

    public void setData(List<T> data) {
        this.data = data;
    }
}
```
## 业务逻辑
```
 @Autowired
    private MailMonitor mailMonitor;

    @Autowired
    private RfidReceiveMailLogMapper rfidReceiveMailLogMapper;

    @Autowired
    private BorrowingService borrowingService;

    /**
     * 邮件附件存储位置
     * @author hefan
     * @date 2018/11/9 16:08
     */
    @Value("${custom.mail.attachments.save.path}")
    private String MAIL_ATTACHMENTS_SAVE_PATH;

    /**
     * 附件保存前缀
     */
    @Value("${custom.mail.attachments.save.prefix}")
    private String MAIL_ATTACHMENTS_SAVE_PREFIX;

    /**
     * 邮件名匹配关键词
     * @author hefan
     * @date 2018/11/10 15:02
     */
    @Value("${custom.mail.match.key}")
    private String MAIL_MATCH_KEY;

    @Override
    public void read() {
        IMAPFolder folder = null;
        try {
            folder = mailMonitor.getAndOpen();
            //获取总邮件数
            logger.debug("-----------------共有邮件：" + folder.getMessageCount() + " 封--------------");
            logger.debug("-----------------未读邮件数：" + folder.getUnreadMessageCount() + "--------------");
            List<Message> messages = Stream.of(folder.getMessages())
                    .filter(this::isNotRead)
                    .collect(Collectors.toList());
            if(CollectionUtils.isEmpty(messages)){
                logger.debug("-----------------no unread mail--------------");
                return;
            }
            AttachmentDetail<ReleaseMail> detail = null;
            List<ReleaseMail> data = null;
            List<Paramer> parameters = null;
            for (Message message : messages) {
                try {
                    detail = analyzeAndRecordLog(message);
                    data = detail.getData();
                    if(CollectionUtils.isEmpty(data)){
                        continue;
                    }
                    logger.debug("mail release start...");
                    //邮件释放开始
                    parameters = data.stream()
                            .map(ReleaseMail::convertToParameter)
                            .collect(Collectors.toList());
                    borrowingService.mailRelease(parameters);
                    logger.debug("mail release end...");
                } catch (Exception e){
                    logger.error("analyze and record log error，msgNumber:"
                            + message.getMessageNumber()
                            + ",parameters:"
                            + JSON.toJSONString(parameters), e);
                }
            }
            logger.debug("-----------------finish insert mail log--------------");
        } catch (MessagingException e){
            logger.error("recevice message error！", e);
        } finally {
            if(null != folder){
                try {
                    folder.close(true);
                } catch (MessagingException e) {
                    logger.error("close mail folder error！", e);
                }
            }
        }
    }

    /**
     * 判断是否已读
     * @author hefan
     * @date 2018/11/9 15:49
     */
    public boolean isNotRead(Message message){
        boolean flag = false;
        try {
            flag = MailUtils.isSeen((MimeMessage) message);
        } catch (MessagingException e){
            logger.error("判断邮件读取状态异常！");
        }
        return !flag;
    }

    /**
     * 分析并记录日志
     * @author hefan
     * @date 2018/11/10 15:20
     */
    public AttachmentDetail analyzeAndRecordLog(Message msg) throws Exception {
        boolean isContainAttachment = MailUtils.isContainAttachment(msg);
        if (!isContainAttachment) {
            logger.error("mail no attachments！msgNumber:" + msg.getMessageNumber());
            return new AttachmentDetail();
        }
        AttachmentDetail detail = null;
        RfidReceiveMailLog mailLog = new RfidReceiveMailLog();
        mailLog.setAddress(MailUtils.getFrom((MimeMessage) msg));
        //save attachment
        detail = MailUtils.saveAttachment(msg, MAIL_ATTACHMENTS_SAVE_PATH,
                MAIL_MATCH_KEY, MAIL_ATTACHMENTS_SAVE_PREFIX, ReleaseMail.class);
        if(null == detail){
            logger.error("illegal attachments！msgNumber:" + msg.getMessageNumber());
            return new AttachmentDetail();
        }
        mailLog.setAttachmentSaveName(detail.getSaveName());
        mailLog.setAttachmentSourceName(detail.getSourceName());
        mailLog.setContent(msg.getContent() + "");
        mailLog.setMsgNumber(msg.getMessageNumber());
        mailLog.setReceivedDate(msg.getReceivedDate());
        mailLog.setSentDate(msg.getSentDate());
        mailLog.setSubject(msg.getSubject());
        rfidReceiveMailLogMapper.insertSelective(mailLog);
        return detail;
    }
```


