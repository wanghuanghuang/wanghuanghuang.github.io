# 平台2 单元测试 指南（试水）



| 版本  | 时间       | 作者   | 内容 |
| ----- | ---------- | ------ | ---- |
| Beta1 | 2019-03-06 | 金惠来 | 新建 |
|       |            |        |      |
|       |            |        |      |



本文档旨在

* 高效又快捷的推广并落地单元测试。
* 结合当前项目实际情况，尽可能的满足单元测试中重要规范，为后续：可持续集成、持续交付、持续部署夯实基础。
* 理想很丰满，现实很骨感，如果不适，欢迎讨论。

计划分为三个步骤落实本文档内容

1. 培训（平台2全员达成共识，了解mockito DEMO及基本用法）
2. 试行（在开发周期中，将部分核心需求按照路径覆盖率完成单元测试编写）
3. 完善并推广（结合2试行期间发现的问题对规则进行填充，制作单元测试标准RELEASE版本，并推行）



## 目录

[TOC]



## 单元测试介绍

单元测试(Unit Test)是面向函数级别的测试用例，由开发人员编写，测试某个或者多个函数的功能。单元测试环境应该容易搭建和运行，运行时一般不依赖其它的服务：如数据库，缓存，第三方服务等，所以在产生其它依赖的地方往往需要 mock 框架，如此有利于提升开发效率。单元测试注重覆盖率，通常情况下，70-80% 左右的覆盖率往往满足绝大部分场景。

### 单元测试的意义

> * 尽早发现缺陷，降低开发投入成本
>
>   * 85%的缺陷是代码阶段产生的，单元测试阶段可以发现绝大部分软件缺陷。同时软件产品的缺陷发现的越早往往会大大的降低其开发的投入成本，其缺陷的发现时间与修复缺陷的成本如下图中红色曲线。红色曲线表明随着软件开发的进行，漏洞越早发现，其修复的成本越低，并且其修复成本与开发进度的上升趋势越在后期越接近于指数上升。![img](https://pic4.zhimg.com/v2-4384d5c22729e14e692501e2fd0bad47_b.jpg)
> * 放心重构
> * 改进设计

###  单元测试的常见误解

>* 单元测试浪费了太多的时间【现状】
>   * 虽然不进行单元测试可以更快的交付到后续测试阶段，但是在后续集成测试阶段、系统测试阶段会发现更多的缺陷甚至软件无法运行的致命缺陷，这些缺陷修复的时间远超过单元测试的时间。另外没有单元测试的代码后期软件进行重构或者改进时花费的时间也比有单元测试的所花费的时间要多很多。所以说完整计划下的单元测试是对时间的更高效的利用。
>* 已经有接口集成测试、系统功能测试进行质量保证了，集成测试阶段对接口进行全面测试就可以达到单元测试的要求，没必要做重复工作在进行单元测试【现状】
>   * 接口测试和功能测试无法覆盖所有的代码，这样如果缺陷存在则将被遗漏，并且Bug将被带到生产上去。一旦用户使用过程中触发了这些没有测试的代码就会带来严重的经济后果。
>* 跑通一个业务主流程等价于做过单元测试【现状】
>   * 目前有很多开发人员认为，开发完代码之后，写个main方法，从入口调完所有的模块，最后验证下返回结果，就认为做过单元测试了，这种想法是及其错误的，这充其量算一种不全面的冒烟测试，是对单元测试概念的错误认知。
>
>

### 优秀的单元测试用例的规范要求

> 1. 必须遵守 AIR 原则
>
>    单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 A：Automatic（自动化） I：Independent（独立性） R：Repeatable（可重复）
>
> 2. 单元测试应该是全自动执行的，并且非交互式的
>
>    测试框架通常是定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。
>
> 3. 保持单元测试的独立性
>
>    为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。反例：method2 需要依赖 method1 的执行，将执行结果做为 method2 的输入
>
> 4. 单元测试是可以重复执行的，不能受到外界环境的影响
>
>    单元测试通常会被放到持续集成中，每次有代码 check in时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。
>
> 5. 对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别
>
>    只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域
>
> 6. 核心业务、核心应用、核心模块的增量代码确保单元测试通过
>
>    新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正
>
> 7. 单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下
>
>    源码构建时会跳过此目录，而单元测试框架默认是扫描此目录



## mock简介

一个单元测试需要在隔离的环境下执行。如果可以的话需要消除其他依赖的服务影响。但实际上,软件中是充满依赖关系的.我们会基于service类写操作类,而service类又是基于数据访问类(DAOs)的，依次下去。为了解决这个问题，可以使用Mock和Stub两种测试代码功能的方法。

* Mock测重于对功能的[模拟](https://www.baidu.com/s?wd=%E6%A8%A1%E6%8B%9F&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)。

* Stub测重于对功能的测试重现。

比如对于List接口，Mock会直接对List进行模拟，而Stub会新建一个实现了List的TestList，在其中编写测试的代码。综上所述，强烈建议优先选择Mock方式，因为Mock方式下，模拟代码与测试代码放在一起，易读性好，而且扩展性、灵活性都比Stub好。

### mockito简介

Mockito是一个流行的Mocking(模拟测试)框架，通过使用Mocking框架，它允许你进行创建和配置模拟对象，可以尽可能使unit test独立的。可以与JUnit 无缝互相配合完成测试任务

### mockito简单教程(略)

pom.xml中添加

``` xml
<groupId>org.mockito</groupId>
<artifactId>mockito-all</artifactId>
<scope>test</scope>
<version>1.8.5</version>
</dependency>
```

此处不一一展开讲述用法，直接以文档中的demo做简单描述，后期可以继续完善此文档。

具体API请参考： [Mockito 主页](http://code.google.com/p/mockito/)

由于google的首页被墙，推荐优质第三方网站讲解

* https://sgq0085.iteye.com/blog/2031319
* https://www.jianshu.com/p/91045b0415f0

## 工具(IDE以IDEA为例)

### 安装插件JUNIT GENERATOR 2.0

> 详见：https://www.cnblogs.com/libingbin/p/6007203.html

### 更新模板

选择Setting->Other Settings->JUnit Generator->JUnit 4，使用  [附件1](#fj1) 覆盖。

### 使用

在待测试类(com/diditech/iov/aaa/service/Xxx.java)中，ALT+Insert插入，选择JUnit->JUnit4，自动生成src/test/java/com/diditech/iov/aaa/service/XxxTest.java，在其中进行单元测试用例编写。



## DEMO

#### 需求

> 根据设备编号和设备接线方式更新设备的接线方式

service层伪代码：

> 1. 根据设备编号查询设备信息
> 2. 判断1的结果是否为空
>    1. 为空，抛出业务异常2-1
>    2. 不为空，继续执行
> 3. 判断1的结果是否大于1条数据
>    1. 大于1，抛出业务异常3-1
>    2. 不为空，继续执行
> 4. 根据1的设备ID更新设备接线方式

#### 设计用例方法

有效的进行单元测试，需要遵循一定的方法，通常采用路径覆盖法设计单元测试用例。所谓路径覆盖法就是选取足够多的测试数据，使程序的每条可能路径都至少执行一次（如果程序图中有环，则要求每个环至少经过一次）[待明确]。具体设计过程参见如下步骤

> ```text
> 1.画出程序控制流程图
> 2.计算圈复杂度
> 3.找出所有程序基本路径
> 4.根据路径设计测试数据
> ```

#### 基本路径

假设参数：

​	设备编号：“dn”；接线方式：“OBD”；

由上述路径覆盖法得到基本路径path

> path1. DB中不存在“dn"；更新设备接线方式“OBD”；预期值：抛出业务异常2-1
>
> path2. DB中存在一条“dn”；更新设备接线方式“OBD”；预期值：通过测试
>
> path3. DB中存在一条“dn”；更新设备接线方式不为“OBD”；预期值：不通过测试
>
> path4. DB中存在两条“dn”；更新设备接线方式“OBD”；预期值：抛出业务异常3-1

### demo1-(方法级)

​	囊括：service/mapper/util等java类上的各种方法

#### 代码结构

> ```java
> package com.diditech.iov.vehicle.service.impl;
> 
> import ...
> 
> @Service
> @Transactional(readOnly = true)
> public class DeviceServiceImpl implements DeviceService {
> 
>    @Autowired
>    VehDeviceMapper vehDeviceMapper;
> 
>    @Override
>     @Transactional(readOnly = false)
>    public ResponseMessage updateWiringModeByDeviceNum(VehDevice device) {
>       VehDeviceExample vehDeviceExample = new VehDeviceExample();
>       vehDeviceExample.createCriteria().andDeviceNumEqualTo(device.getDeviceNum()).andIsdelEqualTo(Constant.BYTE_ZERO);
>       List<VehDevice> list = vehDeviceMapper.selectByExample(vehDeviceExample);
>       if(CollectionUtils.isEmpty(list)){
>          throw new BusinessException("设备号不存在");
>       }
>       if(list.size()>1){
>          throw new BusinessException("设备号存在多个信息，请联系管理员");
>       }
>       VehDevice updateD = new VehDevice();
>       updateD.setId(list.get(0).getId());
>       updateD.setWiringMode(device.getWiringMode());
>       updateD.setUpdateId(ContextUtils.getLoginUserId());
>       updateD.setUpdateTime(Calendar.getInstance().getTime());
>       return vehDeviceMapper.updateByPrimaryKeySelective(updateD) > 0 ? ResponseMessage.ok() : ResponseMessage.error("更新失败");
>    }
> }
> ```

#### 测试代码

> ```java
> package com.diditech.iov.vehicle.service.impl; 
> 
> import com.alibaba.fastjson.JSONObject;
> import com.diditech.iov.bean.mapper.po.VehDeviceMapper;
> import com.diditech.iov.bean.po.VehDevice;
> import com.diditech.iov.core.domain.Constant;
> import com.diditech.iov.core.exception.BusinessException;
> import com.diditech.iov.core.message.ResponseMessage;
> import org.assertj.core.api.Assertions;
> import org.junit.Assert;
> import org.junit.Test;
> import org.junit.Before; 
> import org.junit.After; 
> import org.junit.runner.RunWith;
> import org.mockito.*;
> import org.springframework.boot.test.context.SpringBootTest;
> import org.springframework.test.context.junit4.SpringRunner;
> import com.diditech.iov.Application;
> import com.diditech.iov.base.BaseMockTest;
> 
> import java.util.ArrayList;
> import java.util.List;
> import java.util.Optional;
> 
> import static org.mockito.Matchers.anyObject;
> import static org.mockito.Mockito.verify;
> import static org.mockito.Mockito.when;
> 
> /**
> * DeviceServiceImpl Tester. 
> * 
> * @author lionel 
> * @since <pre>03/05/2019</pre> 
> * @version 1.0 
> */ 
> @RunWith(SpringRunner.class)
> @SpringBootTest(classes = Application.class)
> public class DeviceServiceImplTest extends BaseMockTest{
> 
>     @Mock
>     VehDeviceMapper vehDeviceMapper;
> 
>     @InjectMocks//被注入mock对象的类一般是被测试类
>     DeviceServiceImpl deviceService;
> 
>     Integer deviceId = 1;
>     String deviceNum = "111111111";
>     Byte wiringMode = Constant.BYTE_ONE;
>     List<VehDevice> vdList_0 = new ArrayList<>();
>     List<VehDevice> vdList_1 = new ArrayList<>();
>     List<VehDevice> vdList_2 = new ArrayList<>();
> 
>     @Before
>     @Override
>     public void beforeSetUp() throws Exception {
>         super.beforeSetUp();
>         //mock数据预期数据
>         VehDevice d1 = new VehDevice();
>         d1.setId(deviceId);
>         d1.setWiringMode(wiringMode);
>         d1.setDeviceNum(deviceNum);
>         vdList_1.add(d1);
>         vdList_2.add(d1);
>         VehDevice d2 = new VehDevice();
>         d2.setId(2);
>         d2.setWiringMode(wiringMode);
>         d2.setDeviceNum(deviceNum);
>         vdList_2.add(d2);
>     }
> 
> 
>     //demo1-path1. DB中不存在“dn"；更新设备接线方式“OBD”；预期值：抛出业务异常2-1
>     @Test
>     public void testUpdateWiringModeByDeviceNum_path11() throws Exception {
>         when(vehDeviceMapper.selectByExample(anyObject())).thenReturn(vdList_0);
>         when(vehDeviceMapper.updateByPrimaryKeySelective(anyObject())).thenReturn(1);
>         //测试
>         VehDevice param = new VehDevice();
>         param.setDeviceNum(deviceNum);
>         param.setId(deviceId);
>         param.setWiringMode(wiringMode);
>         try {
>             ResponseMessage rm = deviceService.updateWiringModeByDeviceNum(param);
>             //没有抛出异常测试不通过
>             Assertions.failBecauseExceptionWasNotThrown(RuntimeException.class);
>         } catch (Exception se) {
>         }
>     }
> 
>     //demo1-path2. DB中存在一条“dn”；更新设备接线方式“OBD”；预期值：通过测试
>     @Test
>     public void testUpdateWiringModeByDeviceNum_path12() throws Exception {
>         when(vehDeviceMapper.selectByExample(anyObject())).thenReturn(vdList_1);
>         when(vehDeviceMapper.updateByPrimaryKeySelective(anyObject())).thenReturn(1);
>         //测试
>         VehDevice param = new VehDevice();
>         param.setDeviceNum(deviceNum);
>         param.setId(deviceId);
>         param.setWiringMode(wiringMode);
>         ResponseMessage rm = deviceService.updateWiringModeByDeviceNum(param);
>         // 创建ArgumentCaptor（参数捕获器）用于捕获方法参数进行验证
>         ArgumentCaptor<VehDevice> argument = ArgumentCaptor.forClass(VehDevice.class);
>         // 该方法被调用多次 只能捕捉到最后一次参数
>         verify(vehDeviceMapper).updateByPrimaryKeySelective(argument.capture());
>         System.out.println(JSONObject.toJSONString(argument.getAllValues()));
>         VehDevice result = Optional.ofNullable(argument.getAllValues())
>                 .orElseThrow(() -> new BusinessException("错误"))
>                 .stream().findFirst().get();
>         Assert.assertTrue("更新不成功", rm.isSuccess());
>         Assert.assertTrue("更新的设备ID不正确", deviceId.equals(result.getId()));
>         Assert.assertTrue("更新的设备接线类型不正确",wiringMode.equals(result.getWiringMode()));
>     }
> 
>     //demo1-path3. DB中存在一条“dn”；更新设备接线方式不为“OBD”；预期值：不通过测试
>     @Test
>     public void testUpdateWiringModeByDeviceNum_path13() throws Exception {
>         when(vehDeviceMapper.selectByExample(anyObject())).thenReturn(vdList_1);
>         when(vehDeviceMapper.updateByPrimaryKeySelective(anyObject())).thenReturn(1);
>         //测试
>         VehDevice param = new VehDevice();
>         param.setDeviceNum(deviceNum);
>         param.setId(deviceId);
>         param.setWiringMode(Constant.BYTE_TWO);
>         ResponseMessage rm = deviceService.updateWiringModeByDeviceNum(param);
>         // 创建ArgumentCaptor（参数捕获器）用于捕获方法参数进行验证
>         ArgumentCaptor<VehDevice> argument = ArgumentCaptor.forClass(VehDevice.class);
>         // 该方法被调用多次 只能捕捉到最后一次参数
>         verify(vehDeviceMapper).updateByPrimaryKeySelective(argument.capture());
>         //System.out.println(JSONObject.toJSONString(argument.getAllValues()));
>         VehDevice result = Optional.ofNullable(argument.getAllValues())
>                 .orElseThrow(() -> new BusinessException("错误"))
>                 .stream().findFirst().get();
>         Assert.assertTrue("更新成功", rm.isSuccess());
>         Assert.assertTrue("更新的设备ID正确", deviceId.equals(result.getId()));
>         Assert.assertTrue("更新的设备接线类型正确(预期不正确)",!wiringMode.equals(result.getWiringMode()));
>     }
> 
>     //demo1-path4. DB中存在两条“dn”；更新设备接线方式“OBD”；预期值：抛出业务异常3-1
>     @Test
>     public void testUpdateWiringModeByDeviceNum_path14() throws Exception {
>         when(vehDeviceMapper.selectByExample(anyObject())).thenReturn(vdList_0);
>         when(vehDeviceMapper.updateByPrimaryKeySelective(anyObject())).thenReturn(1);
>         //测试
>         VehDevice param = new VehDevice();
>         param.setDeviceNum(deviceNum);
>         param.setId(deviceId);
>         param.setWiringMode(wiringMode);
>         try {
>             ResponseMessage rm = deviceService.updateWiringModeByDeviceNum(param);
>             //没有抛出异常测试不通过
>             Assertions.failBecauseExceptionWasNotThrown(RuntimeException.class);
>         } catch (Exception se) {
>         }
>     }
> 
> } 
> ```

### demo2-（URL级）

​	类似于现有swagger-ui和postman等工具，不同的是mockMvc可以去交互。

#### 代码结构

> ```java
> package com.diditech.iov.vehicle.controller;
> 
> import ...
> 
> @RestController
> @RequestMapping("/vehicle")
> @AccessLogger(value = "车辆档案")
> public class DeviceController {
> 
>    public static final Logger logger = LoggerFactory.getLogger(DeviceController.class);
> 
>    @Autowired
>    DeviceService deviceService;
> 
>    @AccessLogger(value = "更新设备接线方式（工单调用）")
>    @RequestMapping(value = "/devices/wiring-mode", method = RequestMethod.PUT)
>    @ApiOperation(value = "更新设备接线方式（工单调用）", httpMethod = "PUT", response = ResponseMessage.class, notes = "更新设备接线方式（工单调用）")
>    public ResponseMessage updateWiringModeByDeviceNum(@RequestBody VehDevice device) {
>       if(StringUtils.isBlank(device.getDeviceNum()) || null==device.getWiringMode()){
>          throw new BusinessException("设备号或接线方式参数不正确");
>       }
>       return deviceService.updateWiringModeByDeviceNum(device);
>    }
> 
> }
> ```

#### 测试代码

> ```java
> package com.diditech.iov.vehicle.service.impl; 
> 
> import ...
> /**
> * DeviceServiceImpl Tester. 
> * 
> * @author lionel 
> * @since <pre>03/05/2019</pre> 
> * @version 1.0 
> */ 
> @RunWith(SpringRunner.class)
> @SpringBootTest(classes = Application.class)
> public class DeviceServiceImplTest extends BaseMockTest{
> 
>  @Mock
>  VehDeviceMapper vehDeviceMapper;
> 
>  @InjectMocks//被注入mock对象的类一般是被测试类
>  DeviceServiceImpl deviceService;
> 
>  Integer deviceId = 1;
>  String deviceNum = "111111111";
>  Byte wiringMode = Constant.BYTE_ONE;
>  Byte wiringMode2 = Constant.BYTE_TWO;
>  Integer deviceId2 = 2;
>  List<VehDevice> vdList_0 = new ArrayList<>();
>  List<VehDevice> vdList_1 = new ArrayList<>();
>  List<VehDevice> vdList_2 = new ArrayList<>();
> 
>  @Before
>  @Override
>  public void beforeSetUp() throws Exception {
>      super.beforeSetUp();
>      //mock数据预期数据
>      VehDevice d1 = new VehDevice();
>      d1.setId(deviceId);
>      d1.setWiringMode(wiringMode);
>      d1.setDeviceNum(deviceNum);
>      vdList_1.add(d1);
>      vdList_2.add(d1);
>      VehDevice d2 = new VehDevice();
>      d2.setId(deviceId2);
>      d2.setWiringMode(wiringMode);
>      d2.setDeviceNum(deviceNum);
>      vdList_2.add(d2);
>  }
> 
> 
>  //demo2-path1. DB中不存在“dn"；更新设备接线方式“OBD”；预期值：抛出业务异常2-1
>  @Test
>  public void testUpdateWiringModeByDeviceNum_path21() throws Exception {
>      //测试参数
>      VehDevice param = new VehDevice();
>      param.setDeviceNum("14141778080");
>      param.setWiringMode(wiringMode);
>      MvcResult result = this.mockMvc
>              //perform执行一个请求
>              .perform(
>                      //构建一个请求
>                      put("/vehicle/devices/wiring-mode")
>                              .contentType(MediaType.APPLICATION_JSON)
>                              .content(JSONObject.toJSONString(param))
>                              .requestAttr("USER-INFO", currentUser))
>              //增加断言：预期请求返回状态码200
>              .andExpect(status().isOk())
>              //添加结果处理器，此处加打印处理器
>              .andDo(print())
>              //返回相应结果，进行自定义验证/进行下一步的异步处理；
>              .andReturn();
> 
>  }
>  
> } 
> 
> ```

说明：

1. `MockMvcBuilder`是用来构造`MockMvc`的构造器，其主要有两个实现

    * `StandaloneMockMvcBuilder` ：独立安装实现
       * 此种方式并不会集成真正的web环境，而是通过相应的`Mock API`进行模拟测试，无须启动服务器

   * `DefaultMockMvcBuilder`：集成Web环境实现
     * 正常启动容器

   由于平台依赖于spring依赖注入，所以统一使用集成web环境。

2. 由于mockmvc这种测试方法，模拟不了数据，同postman和swagger-ui一样，都需要DB数据的支持。此处就不对测试路径一一列出



### 总结

​	以上罗列了mock常见的两种测试方法：方法级（demo1）与URL级（demo2）

​	总结一下优缺点：

|                       | 方法级-demo1 | URL级-demo2         |
| --------------------- | ------------ | ------------------- |
| Automatic（自动化）   | √            | √                   |
| Independent（独立性） | √            | ×（单元间耦合度高） |
| Repeatable（可重复）  | √            | ×（依赖DB）         |
| 测试粒度              | 小           | 大                  |
| 编写复杂度及耗时      | 复杂，耗时   | 较为简单，耗时      |

​	综上，方法级测试的模拟数据可以更好的将单元之间的依赖解耦，更符合AIR原则；而URL级的测试，更像是单元测试之后的测试，更接近于接口的功能测试，也是目前大家多在使用的“单元测试”方式。同样的，方法级的测试复杂度和耗时都相当可观，但是做好以后可以达到“一劳永逸”的目标，用自动化的测试减少后期的测试工作。

​	目前该份指南文档还在起草阶段，可执行的落地规范还需要在迭代中按照本文档先试行一下，再做总结和完善，如有问题。

​	在起草中难免出现偏差纰漏，如有问题还请各位多多指出，谢谢。

​	











## 附录：名称解释

* 单元测试(Unit Test)是面向函数级别的测试用例，由开发人员编写，测试某个或者多个函数的功能。单元测试环境应该容易搭建和运行，运行时一般不依赖其它的服务：如数据库，缓存，第三方服务等，所以在产生其它依赖的地方往往需要 mock 框架，如此有利于提升开发效率。单元测试注重覆盖率，通常情况下，70-80% 左右的覆盖率往往满足绝大部分场景。

* 集成测试(Integration Test)是面向 API 级别的测试用例，由开发／测试人员编写，测试一个或者多个 API 的功能是否正常，多个组件之间是否互相配合，正常工作。集成测试环境的搭建相对比较复杂，它可能依赖数据库，缓存，第三方服务等，一般为大家共用。



* 性能测试(Performance Test)主要用于测试性能，分析性能瓶颈等，属于高级别的测试类似。受多种条件影响，不同应用的性能测试方式各有差异，在此不多展开。

##  附件
###  附件一 JUnit4 模板
>  ######################################################################################## 
>  ## 
>  ## Available variables: 
>  ##         $entryList.methodList - List of method composites 
>  ##         $entryList.privateMethodList - List of private method composites 
>  ##         $entryList.fieldList - ArrayList of class scope field names 
>  ##         $entryList.className - class name 
>  ##         $entryList.packageName - package name 
>  ##         $today - Todays date in MM/dd/yyyy format 
>  ## 
>  ##            MethodComposite variables: 
>  ##                $method.name - Method Name 
>  ##                $method.signature - Full method signature in String form 
>  ##                $method.reflectionCode - list of strings representing commented out reflection code to access method (Private Methods) 
>  ##                $method.paramNames - List of Strings representing the method's parameters' names 
>  ##                $method.paramClasses - List of Strings representing the method's parameters' classes 
>  ## 
>  ## You can configure the output class name using "testClass" variable below. 
>  ## Here are some examples: 
>  ## Test${entry.ClassName} - will produce TestSomeClass 
>  ## ${entry.className}Test - will produce SomeClassTest 
>  ## 
>  ######################################################################################## 
>  ## 
>  #macro (cap $strIn)$strIn.valueOf($strIn.charAt(0)).toUpperCase()$strIn.substring(1)#end 
>  ## Iterate through the list and generate testcase for every entry. 
>  #foreach ($entry in $entryList) 
>  #set( $testClass="${entry.className}Test") 
>  ## 
>  package $entry.packageName; 
>
>  import org.junit.Test; 
>  import org.junit.Before; 
>  import org.junit.After; 
>  import org.junit.runner.RunWith;
>  import org.springframework.boot.test.context.SpringBootTest;
>  import org.springframework.test.context.junit4.SpringRunner;
>  import com.diditech.iov.Application;
>  import com.diditech.iov.base.BaseMockTest;
>  /** 
>  * ${entry.className} Tester. 
>  * 
>  * @author lionel 
>  * @since <pre>$today</pre> 
>  * @version 1.0 
>    */ 
>    @RunWith(SpringRunner.class)
>    @SpringBootTest(classes = Application.class)
>    public class $testClass extends BaseMockTest{ 
>
>      @Before
>      @Override
>      public void beforeSetUp() throws Exception {
>          super.beforeSetUp();
>      }
>
>      @After
>      public void after() throws Exception { 
>      } 
>
>  #foreach($method in $entry.methodList) 
>      /** 
>      * 
>      * Method: $method.signature 
>      * 
>      */ 
>      @Test
>      public void test#cap(${method.name})() throws Exception { 
>      //TODO: Test goes here... 
>      } 
>
>  #end 
>
>  #foreach($method in $entry.privateMethodList) 
>      /** 
>      * 
>      * Method: $method.signature 
>      * 
>      */ 
>      @Test
>      public void test#cap(${method.name})() throws Exception { 
>      //TODO: Test goes here... 
>      #foreach($string in $method.reflectionCode) 
>      $string 
>      #end 
>      } 
>
>  #end 
>  } 
>  #end



### 附件二 BaseMockTest基类

> ```
> package com.diditech.iov.base;
> 
> import com.diditech.iov.bean.mapper.po.AccUserMapper;
> import com.diditech.iov.bean.po.AccUser;
> import com.diditech.iov.core.utils.ContextUtils;
> import org.junit.Before;
> import org.mockito.Mock;
> import org.mockito.MockitoAnnotations;
> import org.springframework.beans.factory.annotation.Autowired;
> import org.springframework.test.web.servlet.MockMvc;
> import org.springframework.test.web.servlet.setup.MockMvcBuilders;
> import org.springframework.web.context.WebApplicationContext;
> 
> import javax.servlet.http.HttpServletRequest;
> 
> /**
>  * @ClassName BaseMockTest
>  * @Description mock基类
>  * @Auth Lionel
>  * @Date 2019-02-22 10:43
> **/
> public abstract class BaseMockTest {
> 
>  @Autowired
>  protected AccUserMapper accUserMapper;
> 
>  @Autowired
>  private WebApplicationContext wc;
> 
>  protected MockMvc mockMvc;
> 
>  protected String accessToken = "";
>  protected AccUser currentUser;
>  @Mock
>  protected HttpServletRequest request;
>  @Before
>  public void beforeSetUp() throws Exception {
>      this.mockMvc = MockMvcBuilders.webAppContextSetup(wc).build();
>      //注册
>      MockitoAnnotations.initMocks(this);
>      //登录用户
>      currentUser = accUserMapper.selectByPrimaryKey(10);
>      ContextUtils.getRequest().setAttribute("USER-INFO", currentUser);
>  }
> 
> }
> ```