---
title: 导出工具类
date: 2018-12-24 14:25:11
tags:
---


导出工具类：
```
import com.diditech.iov.core.utils.excel.dyncolumn.DynamicColumnData;
import com.diditech.iov.core.exception.BusinessException;
import com.diditech.iov.core.exception.SystemException;
import com.diditech.iov.core.utils.BrowserUtil;
import com.diditech.iov.core.utils.PropertiesHolder;
import net.sf.jxls.exception.ParsePropertyException;
import net.sf.jxls.transformer.XLSTransformer;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.List;
import java.util.Map;

@Component
public class DownloadHelper {
	private final static Logger Logger = LoggerFactory.getLogger(DefaultExcelReportGenerator.class);

	/**
	 * excel2007后缀名(.xlsx)
	 */
	public final static String XLSX_FILE_TYPE = ".xlsx";

	/**
	 * 文件下载(浏览器端)
	 * 
	 * @param templateName
	 * @param dataSet
	 * @param response
	 * @param request
	 * @param holder
	 * @param downloadName
	 * @param fileType
	 */
	public static void downloadReport(HttpServletResponse response, HttpServletRequest request, String downloadName,
			String fileType) {
		try {
			response.setContentType("application/msexcel");// 定义输出类型
			// response.setHeader("Content-Disposition","attachment;filename=" +
			// URLEncoder.encode(this.downloadName, "UTF-8") + this.fileType);
			// 格式化(UTF-8)文件名
			downloadName = BrowserUtil.processFileName(request, downloadName);
			response.setHeader("Content-Disposition", "attachment;filename=" + downloadName + fileType);
			response.getOutputStream().flush();
			response.getOutputStream().close();
		} catch (IOException e) {
			Logger.warn("fail to output the report!");
			throw new SystemException("fail to output the report!", e);
		}
	}

	/**
	 * 文件下载(浏览器端)
	 * 
	 * @param response
	 * @param request
	 * @param fileAllPath
	 * @param downloadName
	 * @param fileType
	 * @return
	 */
	public static ResponseEntity<byte[]> downloadReport(HttpServletResponse response, HttpServletRequest request,
			String fileAllPath, String downloadName, String fileType) {
		ResponseEntity<byte[]> entity = null;
		try {
			HttpHeaders headers = new HttpHeaders();
			HttpStatus httpState = HttpStatus.NOT_FOUND;
			File file = new File(fileAllPath);
			byte[] body = null;
			if (file.exists() && file.isFile()) {
				Logger.debug("{}准备下载文件,{}", fileAllPath, downloadName);
				InputStream is = new FileInputStream(file);
				body = new byte[is.available()];
				is.read(body);
				is.close();
				// headers.add("Content-Type", "application/vnd.ms-excel");
				headers.add("Content-Type", "application/msexcel");
				headers.add("Content-Length", "" + body.length);
				headers.add("Content-Disposition",
						"attachment;filename=" + encodeFileName(downloadName + fileType, request));
				httpState = HttpStatus.OK;
				entity = new ResponseEntity<byte[]>(body, headers, httpState);
			} else {
				Logger.debug("{}没有文件或不是文件,{}", fileAllPath, downloadName);
				throw new BusinessException("下载失败，找不到文件");
			}
		} catch (IOException e) {
			Logger.error("fail to output the report!");
			throw new SystemException("fail to output the report!", e);
		}
		return entity;
	}

	/**
	 * 文件下载(浏览器端)
	 * 
	 * @author Lionel
	 * @date 2017年7月6日 下午8:11:41
	 * @param response
	 * @param request
	 * @param is
	 * @param downloadName
	 * @param fileType
	 * @return
	 */
	public static ResponseEntity<byte[]> downloadReport(HttpServletResponse response, HttpServletRequest request,
			InputStream is, String downloadName, String fileType) {
		ResponseEntity<byte[]> entity = null;
		try {
			HttpHeaders headers = new HttpHeaders();
			HttpStatus httpState = HttpStatus.NOT_FOUND;
			byte[] body = null;
			int temp = is.available();
			// LOG.debug("is size:{}", temp);
			body = new byte[temp];
			is.read(body);
			is.close();
			// headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
			// headers.add("Content-Type", "application/msexcel");
			headers.add("Content-Type", "application/octet-stream");
			headers.add("Content-Length", "" + body.length);
			// LOG.debug("body.length:{}", body.length);
			headers.add("Content-Disposition",
					"attachment;filename=" + encodeFileName(downloadName + fileType, request));
			httpState = HttpStatus.OK;
			entity = new ResponseEntity<byte[]>(body, headers, httpState);

		} catch (Exception e) {
			Logger.error("下载异常", e);
			throw new SystemException("fail to output the report!", e);
		}
		return entity;
	}

	/**
	 * 文件下载(浏览器端)
	 * 
	 * @param response
	 * @param request
	 * @param fileAllPath
	 * @param downloadName
	 * @param fileType
	 * @return
	 */
	public static ResponseEntity<byte[]> downloadReport(HttpServletResponse response, HttpServletRequest request,
			File file, String downloadName, String fileType) {
		ResponseEntity<byte[]> entity = null;
		try {
			HttpHeaders headers = new HttpHeaders();
			HttpStatus httpState = HttpStatus.NOT_FOUND;
			byte[] body = null;
			if (file.exists() && file.isFile()) {
				InputStream is = new FileInputStream(file);
				body = new byte[is.available()];
				is.read(body);
				is.close();
				headers.add("Content-Type", "application/msexcel");
				headers.add("Content-Length", "" + body.length);
				headers.add("Content-Disposition",
						"attachment;filename=" + encodeFileName(downloadName + fileType, request));
				httpState = HttpStatus.OK;
				entity = new ResponseEntity<byte[]>(body, headers, httpState);
			} else {
				Logger.debug("{}没有文件或不是文件,{}", file, downloadName);
				throw new BusinessException("下载失败，找不到文件");
			}
		} catch (IOException e) {
			Logger.error("fail to output the report!");
			throw new SystemException("fail to output the report!", e);
		}
		return entity;
	}

	/**
	 * Excel下载(浏览器端)
	 * 
	 * @param templateName
	 * @param dataSet
	 *            数据
	 * @param response
	 * @param request
	 * @param holder
	 * @param downloadName
	 * @param fileType
	 * @throws Exception
	 */
	public static void downloadExcelReport(String templateName, List<?> dataSet, HttpServletResponse response,
			HttpServletRequest request, PropertiesHolder holder, String downloadName, String fileType)
			throws Exception {
		DefaultExcelReportGenerator g = new DefaultExcelReportGenerator();
		// 下载文件的名字
		g.setDownloadName(downloadName);
		// 下载文件扩展名
		g.setFileType(fileType);
		g.loadTempate(getTemplatePath(templateName, holder));
		g.print(dataSet, response, request);
	}

	/**
	 * Excel下载(浏览器端)
	 * 
	 * @param workbook
	 *            excel
	 * @param response
	 * @param request
	 * @param downloadName
	 * @param fileType
	 */
	public static void downloadExcelReport(Workbook workbook, HttpServletResponse response, HttpServletRequest request,
			String downloadName, String fileType) {
		DefaultExcelReportGenerator g = new DefaultExcelReportGenerator();
		// 下载文件的名字
		g.setDownloadName(downloadName);
		// 下载文件扩展名
		g.setFileType(fileType);
		// g.loadTempate(getTemplatePath(templateName,holder));
		g.print(workbook, response, request);
	}

	/**
	 * Excel下载(文件服务器端 )
	 * 
	 * @param templateName
	 * @param dataSet
	 * @param holder
	 * @param downloadName
	 * @param fileType
	 * @throws FileNotFoundException
	 */
	// add by xueao 2016/11/16 15:05
	public static void downloadExcelReport(String templateName, List<?> dataSet, PropertiesHolder holder,
			String downloadName, String fileType, String path) throws Exception {
		DefaultExcelReportGenerator g = new DefaultExcelReportGenerator();
		g.setDownloadName(downloadName);
		g.setFileType(fileType);
		g.loadTempate(getTemplatePath(templateName, holder));
		File tempPath = new File(path);
		if (!tempPath.exists()) {
			tempPath.mkdirs();
		}
		FileOutputStream out = new FileOutputStream(tempPath.getPath() + File.separator + downloadName + fileType);
		tempPath = null;
		g.print(dataSet, out);
		g = null;
		dataSet.clear();
	}

	/**
	 * Excel下载(文件服务器端 )
	 * 
	 * @param templateName
	 * @param dataSet
	 * @param holder
	 * @param downloadName
	 * @param fileType
	 * @throws IOException
	 */
	public static void downloadExcelReportTwo(String templateName, List<?> dataSet, PropertiesHolder holder,
			String downloadName, String fileType, String path) throws IOException {
		DefaultExcelReportGeneratorTwo g = new DefaultExcelReportGeneratorTwo();
		g.setDownloadName(downloadName);
		g.setFileType(fileType);
		g.loadTempate(getTemplatePath(templateName, holder));
		File tempPath = new File(path);
		if (!tempPath.exists()) {
			tempPath.mkdirs();
		}

		FileOutputStream out = new FileOutputStream(tempPath.getPath() + File.separator + downloadName + fileType);
		tempPath = null;
		Logger.info("exportPositionListType:loadtempate");
		g.print(dataSet, out);
		Logger.info("exportPositionListType:writecomplete");
		g = null;
		dataSet.clear();
	}

	/**
	 * Excel下载(文件服务器端 )JXTL标签的方式
	 * 
	 * @param templateName
	 * @param beans
	 * @param holder
	 * @param downloadName
	 * @param fileType
	 * @throws IOException
	 */
	public static void downloadExcelReportByHJxls(String fileName, Map<String, Object> beans,
			PropertiesHolder holder, String downloadName, String fileType, String path)
			throws ParsePropertyException, InvalidFormatException, IOException {
		File tempFile = new File(holder.getReportTemplateRoot() + fileName);
		if (null == tempFile || !tempFile.exists()) {
			throw new BusinessException("未查询到销售单导出模板文件");
		}
		File outFile = new File(path);
		if (!outFile.exists()) {
			outFile.mkdirs();
		}
		XLSTransformer transformer = new XLSTransformer();
		try (OutputStream out = new FileOutputStream(outFile.getPath() + File.separator + downloadName + fileType);
				InputStream in = new BufferedInputStream(new FileInputStream(tempFile))) {
			Workbook workbook = transformer.transformXLS(in, beans);
			workbook.write(out);
		}catch(Exception ex){
			ex.printStackTrace();
		}
	}

	/**
	 * Excel文件生成
	 * 
	 * @author Lionel
	 * @date 2017年7月19日 下午1:30:35
	 * @param templateName
	 *            模板名称
	 * @param dataSet
	 *            数据集合
	 * @param downloadName
	 *            生成文件名称
	 * @param fileType
	 *            生成文件类型
	 * @param path
	 *            生成文件存放路径
	 * @param absolutePath
	 *            生成文件资源路径
	 * @return 生成文件资源路径
	 * @throws Exception
	 */
	public static String createExcelReport(String templateName, List<?> dataSet, String downloadName, String fileType,
			String path, String absolutePath) throws Exception {
		File tempPathFile = new File(path);
		if (!tempPathFile.exists()) {
			tempPathFile.mkdirs();
		}
		DefaultExcelReportGeneratorTwo g = new DefaultExcelReportGeneratorTwo();
		g.setDownloadName(downloadName);
		g.setFileType(fileType);
		FileOutputStream out = null;
		if (StringUtils.isBlank(absolutePath)) {
			// 本次任务新文件 加载模板
			g.loadTempate(getTemplatePath(templateName));
			String resultStr = tempPathFile.getPath() + File.separator + downloadName + fileType;
			out = new FileOutputStream(resultStr);
			// 销毁临时变量
			tempPathFile = null;
			Logger.debug("createExcelReportNew : loadcomplete");
			g.print(dataSet, out);
			Logger.debug("createExcelReportNew : writecomplete");
			// 销毁临时变量
			g = null;
			// 销毁数据集合
			dataSet.clear();
			return resultStr;
		} else {
			// 本次任务加载已生成文件
			g.loadFile(absolutePath);
			out = new FileOutputStream(absolutePath);
			// 销毁临时变量
			tempPathFile = null;
			Logger.debug("createExcelReportNew : loadcomplete");
			g.appendPrint(dataSet, out);
			Logger.debug("createExcelReportNew : writecomplete");
			// 销毁临时变量
			g = null;
			// 销毁数据集合
			dataSet.clear();
			return absolutePath;
		}
	}

	/**
	 * Excel文件生成---new
	 * 
	 * @author Lionel
	 * @date 2017年7月19日 下午1:30:35
	 * @param templateName
	 *            模板名称
	 * @param dataSet
	 *            数据集合
	 * @param downloadName
	 *            生成文件名称
	 * @param fileType
	 *            生成文件类型
	 * @param path
	 *            生成文件存放路径
	 * @param absolutePath
	 *            生成文件资源路径
	 * @return 生成文件资源路径
	 * @throws Exception
	 */
	public static void createExcelReport2(String templateName, List<?> dataSet, String downloadName, String fileType,
			String path) throws Exception {
		File tempPathFile = new File(path);
		if (!tempPathFile.exists()) {
			tempPathFile.mkdirs();
		}
		FileOutputStream out = null;
		DefaultExcelReportGeneratorTwo g = new DefaultExcelReportGeneratorTwo();
		g = new DefaultExcelReportGeneratorTwo();
		g.setDownloadName(downloadName);
		g.setFileType(fileType);
		g.loadTempate(getTemplatePath(templateName));
		String resultStr = tempPathFile.getPath() + File.separator + downloadName + fileType;
		out = new FileOutputStream(resultStr);
		// 销毁临时变量
		tempPathFile = null;
		Logger.debug("createExcelReportNew : loadcomplete");
		g.print(dataSet, out);
		Logger.debug("createExcelReportNew : writecomplete");
		// 销毁临时变量
		g = null;
		// 销毁数据集合
		dataSet.clear();
	}

	/**
	 * 追加内容
	 * 
	 * @param downloadName
	 * @param dataSet
	 * @param fileType
	 * @throws IOException
	 */
	public static void appendExcel(String downloadName, List<?> dataSet, String fileType, String path)
			throws IOException {
		File file = new File(path + File.separator + downloadName + fileType);
		InputStream in = new FileInputStream(file);
		// HSSFWorkbook work = new HSSFWorkbook(in);
		Workbook work = null;
		if (".xlsx".endsWith(fileType)) {
			work = new XSSFWorkbook(in);
		} else {
			work = new HSSFWorkbook(in);
		}
		DefaultExcelReportGenerator g = new DefaultExcelReportGenerator(work);

		FileOutputStream fos = new FileOutputStream(file);
		g.appendPrint(dataSet, fos);
		in.close();
		dataSet.clear();
	}

	/**
	 * 往excel中追加sheet并写入数据 sheetNum 对应sheet在workbook中的序号
	 */
	public static void appendSheetData(Workbook work, String downloadName, List<?> dataSet, String fileType,
			String path, Integer sheetNum) throws IOException {
		File file = new File(path + File.separator + downloadName + fileType);
		DefaultExcelReportGenerator g = new DefaultExcelReportGenerator(work, sheetNum);
		FileOutputStream fos = new FileOutputStream(file);
		g.appendData(dataSet, fos);
		dataSet.clear();
	}

	/**
	 * 获取模板
	 * 
	 * @param templateName
	 * @param propertiesHolder
	 * @return
	 */
	protected static String getTemplatePath(String templateName, PropertiesHolder propertiesHolder) {
		return File.separator + templateName;
	}

	/**
	 * 获取模板
	 * 
	 * @param templateName
	 * @param propertiesHolder
	 * @return
	 */
	protected static String getTemplatePath(String templateName) {
		return File.separator + templateName;
	}

	/**
	 * 下载文件时，对文件名进行转码
	 * 
	 * @param filePath
	 * @param request
	 * @return
	 * @throws UnsupportedEncodingException
	 */
	public static String encodeFileName(String filePath, HttpServletRequest request)
			throws UnsupportedEncodingException {
		String fileName = filePath.substring(filePath.lastIndexOf("/") + 1);
		String Agent = request.getHeader("User-Agent");
		if (null != Agent) {
			Agent = Agent.toLowerCase();
			if (Agent.indexOf("firefox") != -1) {
				fileName = new String(fileName.getBytes(), "iso8859-1");
			} else if (Agent.indexOf("msie") != -1) {
				fileName = URLEncoder.encode(fileName, "UTF-8");
			} else {
				fileName = URLEncoder.encode(fileName, "UTF-8");
			}
		}
		return fileName;
	}

	/**
	 * Excel下载(文件服务器端 )
	 * 
	 * @param templateName
	 * @param dataSet
	 * @param holder
	 * @param downloadName
	 * @param fileType
	 * @throws IOException
	 */
	public static void downloadExcelReportNew(String templateName, List<?> dataSet, PropertiesHolder holder,
			String downloadName, String fileType, String path) throws IOException {
		DefaultExcelReportGeneratorTwo g = new DefaultExcelReportGeneratorTwo();
		g.setDownloadName(downloadName);
		g.setFileType(fileType);
		g.loadTempate(getTemplatePath(templateName, holder));
		File tempPath = new File(path);
		if (!tempPath.exists()) {
			tempPath.mkdirs();
		}

		FileOutputStream out = new FileOutputStream(tempPath.getPath() + File.separator + downloadName + fileType);
		tempPath = null;
		Logger.info("exportPositionListType:loadtempate");
		g.print(dataSet, out);
		Logger.info("exportPositionListType:writecomplete");
		g = null;
		dataSet.clear();
	}


    /**
     * Excel下载(文件服务器端)
     * 表头多列生成
     * @param dataSet
     * @param dataMap
     * @param downloadName
     * @param fileType   @throws IOException
     */
    public static void downloadExcelReportDynamicColumn(String sheetName, String title, String firstColName,
                                                        DynamicColumnData columnData,String downloadName,
                                                        String fileType, String path) throws Exception {
        DynColumnExcelReportGenerator g = new DynColumnExcelReportGenerator(sheetName,columnData.getRightTotal().size());
        Map<String, List<?>> dataMap = columnData.getDataMap();
        List<?> bottomTotal = columnData.getBottomTotal();
        List<?> rightTotal = columnData.getRightTotal();
        g.setDownloadName(downloadName);
        g.setFileType(fileType);
        g.setTitle(title);
        g.setFirstColName(firstColName);
        g.setHeaderTextSet(columnData.getHeaderTextSet());
        g.setBottomTotal(bottomTotal);
        g.setRightTotal(rightTotal);
        File tempPath = new File(path);
        if (!tempPath.exists()) {
            tempPath.mkdirs();
        }
        FileOutputStream out = new FileOutputStream(tempPath.getPath() + File.separator + downloadName + fileType);
        tempPath = null;
        Logger.info("downloadExcelReportDynamicColumn");
        g.print(dataMap, out);
        g = null;
        dataMap.clear();
    }
```

holder类：
```
import java.io.FileNotFoundException;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.context.ContextLoader;

@Component
public class PropertiesHolder {
    
    @Value("${defaultPage}")
    private int defaultPage;
    
    @Value("${defaultPageSize}")
    private int defaultPageSize;
    
    private String webRoot;
    
    private String uploadImageRoot;
    
    @Value("${reportTemplateRoot}")
    private String reportTemplateRoot;

    private String htmlRoot;
    
    private String htmlImageRoot;
    
    private String cacheOrdersGroups;
    
    public int getDefaultPage() {
        return defaultPage;
    }

    public void setDefaultPage(int defaultPage) {
        this.defaultPage = defaultPage;
    }

    public int getDefaultPageSize() {
        return defaultPageSize;
    }

    public void setDefaultPageSize(int defaultPageSize) {
        this.defaultPageSize = defaultPageSize;
    }

    public String getUploadImageRoot() {
        return uploadImageRoot;
    }

    public void setUploadImageRoot(String uploadImageRoot) {
        this.uploadImageRoot = uploadImageRoot;
    }

    public String getReportTemplateRoot() {
        return reportTemplateRoot;
    }
    
    public void setReportTemplateRoot(String reportTemplateRoot) {
        this.reportTemplateRoot = reportTemplateRoot;
    }

    public void setWebRoot(String webRoot) {
        this.webRoot = webRoot;
    }

    public String getWebRoot() {
        try {
        	
            return org.springframework.web.util.WebUtils.getRealPath(ContextLoader.getCurrentWebApplicationContext().getServletContext(), "/");
        } catch (FileNotFoundException e) {
            return this.webRoot;
        }
    }

    public String getHtmlRoot() {
        return htmlRoot;
    }

    public void setHtmlRoot(String htmlRoot) {
        this.htmlRoot = htmlRoot;
    }

    public String getHtmlImageRoot() {
        return htmlImageRoot;
    }

    public void setHtmlImageRoot(String htmlImageRoot) {
        this.htmlImageRoot = htmlImageRoot;
    }

    public String getCacheOrdersGroups() {
        return cacheOrdersGroups;
    }

    public void setCacheOrdersGroups(String cacheOrdersGroups) {
        this.cacheOrdersGroups = cacheOrdersGroups;
    }

```

配置文件中加入：
```
reportTemplateRoot=
defaultPage=1
defaultPageSize=3
```

使用方法：
```
public static final String EXPORT_RESCUE_ORDER_PREFIX = "RESCUE_ORDER_";
/**
 * 年月日小时分钟秒钟(yyyyMMddHHmmss)
 */
public static final String YEAR_MONTH_DAY_HOUR_MINUTE_SECOND_SIMPLE = "yyyyMMddHHmmss";
/**
 * 救援模板文件
 */
public static final String RESCUE_ORDER_TEMPLATE_NAME = "rescue_order.xlsx";
/**
 * 导出文件类型 xlsx
 */
public static final String FILE_TYPE_XLSX = ".xlsx";

@Value("${localSavePath}")
private String localSavePath;

@Autowired
private PropertiesHolder holder;

 String downloadName = "";
            downloadName = Contants.EXPORT_RESCUE_ORDER_PREFIX + currentUser.getId() + "_"
                    + DateTimeUtils.format(new Date(), DateTimeUtils.YEAR_MONTH_DAY_HOUR_MINUTE_SECOND_SIMPLE);
            try {
                DownloadHelper.downloadExcelReportTwo(Contants.RESCUE_ORDER_TEMPLATE_NAME, list, holder, downloadName,
                        Contants.FILE_TYPE_XLSX, localSavePath);
            } catch (IOException e) {
                logger.error("救援服务单导出失败！", e);
                throw new BusinessException(e.getMessage());
            }
        return EncryptionUtils.encrytBase64(downloadName + Contants.FILE_TYPE_XLSX);
```

shiro进行加密解密的工具类封装
```
import java.util.HashMap;
import java.util.Map;

import org.apache.shiro.codec.Base64;
import org.apache.shiro.codec.Hex;
import org.apache.shiro.crypto.SecureRandomNumberGenerator;
import org.apache.shiro.crypto.hash.Md5Hash;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;

import dd.utils.MD5Util;

/**
 * shiro进行加密解密的工具类封装
 */
public final class EncryptionUtils {
	
	/**
	 * 生成盐长度
	 */
	private static final Integer SALT_LENGTH = 4;   
	
	/**
	 * base64进制加密
	 * 
	 * @param password
	 * @return
	 */
	public static String encrytBase64(String password) {
		Preconditions.checkArgument(!Strings.isNullOrEmpty(password), "加密数据不能为空");
		byte[] bytes = password.getBytes();
		return Base64.encodeToString(bytes);
	}

	/**
	 * base64进制解密
	 * 
	 * @param cipherText
	 * @return
	 */
	public static String decryptBase64(String cipherText) {
		Preconditions.checkArgument(!Strings.isNullOrEmpty(cipherText),
				"消息摘要不能为空");
		return Base64.decodeToString(cipherText);
	}

	/**
	 * 16进制加密
	 * 
	 * @param password
	 * @return
	 */
	public static String encrytHex(String password) {
		Preconditions.checkArgument(!Strings.isNullOrEmpty(password), "加密数据不能为空");
		byte[] bytes = password.getBytes();
		return Hex.encodeToString(bytes);
	}

	/**
	 * 16进制解密
	 * 
	 * @param cipherText
	 * @return
	 */
	public static String decryptHex(String cipherText) {
		Preconditions.checkArgument(!Strings.isNullOrEmpty(cipherText),
				"消息摘要不能为空");
		return new String(Hex.decode(cipherText));
	}

	/**
	 * 对token进行md5加密,并返回密文和salt
	 * 
	 * @param token
	 * @return 密文和salt
	 */
	public static Map<String,String> md5Token(String token) {
		Map<String,String> result = new HashMap<String,String>();
		Preconditions.checkArgument(!Strings.isNullOrEmpty(token),
				"token不能为空");
		String salt = generateSalt();
		// 两次迭代，对token进行加密
		String token_cipherText = new Md5Hash(token + salt,salt, 2)
				.toBase64();
		result.put("token", token_cipherText);
		result.put("salt", salt);
		return result;
	}
	
	public static String md5Token(String token,String salt) {
		Preconditions.checkArgument(!Strings.isNullOrEmpty(token),
				"token不能为空");
		String token_cipherText = new Md5Hash(token + salt,salt, 2)
				.toBase64();
		return token_cipherText;
	}
	
	/**
	 * 对密码加盐进行md5加密,并返回密文和salt
	 * 
	 * @param username
	 *            用户名
	 * @param password
	 *            密码
	 * @return 密文和salt
	 */
	public static Map<String,String> md5Password(String username, String password) {
		Map<String,String> result = new HashMap<String,String>();
		Preconditions.checkArgument(!Strings.isNullOrEmpty(username),
				"username不能为空");
		Preconditions.checkArgument(!Strings.isNullOrEmpty(password),
				"password不能为空");
		String salt = generateSalt();
		// 组合username,两次迭代，对密码进行加密
		String password_cipherText = new Md5Hash(password, username + salt, 2)
				.toBase64();
		result.put("password", password_cipherText);
		result.put("salt", salt);
		return result;
	}
	
	/**
	 * 对密码进行md5加密,并返回密文
	 * 
	 * @param password
	 *            密码
	 * @return 密文
	 */
	public static String md5Password(String password){
		return MD5Util.encrypt(password);
	}
	
	/**
	 * 生成随机盐
	 */
	public static String generateSalt(){
		SecureRandomNumberGenerator secureRandomNumberGenerator = new SecureRandomNumberGenerator();
        return secureRandomNumberGenerator.nextBytes(SALT_LENGTH).toHex();
	}
```

当数据十分大时，就需要后台任务 导出：
```
@Service
public class AlarmNewServiceImpl implements AlarmNewService {

    private static final Logger LOG = LoggerFactory.getLogger(HardAlarmServiceImpl.class);

    @Value("${localSavePath}")
    private String localSavePath;

    @Value("${isShowTestCar}")
    private boolean isShowTestCar;

    @Autowired
    private PropertiesHolder holder;

    @Autowired
    private BackTaskService backTaskService;
    @Autowired
    private AlarmMapper alarmMapper;


    @Autowired
    @Qualifier("redisTemplate")
    public FastJsonRedisTemplate redisTemplate;

    @Value("${EXPORTVEHICLE_LIMIT:5000}")
    private int EXPORTVEHICLE_LIMIT;

    private List<AlarmInfo> paramTransport(List<AlarmInfo> list) {
        list.forEach(record ->{
            record.setAlmSource("平台预警");
            record.setAlmTimeStr(DateTimeUtils.format(record.getAlmTime(),
                    DateTimeUtils.YEAR_MONTH_DAY_HOUR_MINUTE_SECOND));
            if (Constant.BYTE_ONE.equals(record.getHandleStatus())) {
                record.setHandleStatusName("已处理");
            } else {
                record.setHandleStatus( Constant.BYTE_ZERO);
                record.setHandleStatusName("未处理");
            }
            record.setInputTimeStr(DateTimeUtils.format(record.getInputTime(),
                    DateTimeUtils.YEAR_MONTH_DAY_HOUR_MINUTE_SECOND));
            record.setAlmTypeName(AlarmType.getAlarmType(record.getAlmType()).getName());
        });
        return list;
    }

    @Override
    public Boolean getAlarmsExport(AlarmInfoQueryParam queryParam, String threadKey, Set<Integer> groupIdSet) {
        int loginUserId = ContextUtils.getLoginUserId();
        queryParam.setShowTest(isShowTestCar);
        //插入后台任务信息
        boolean cancleFlag = false;
        String tempPath = localSavePath + loginUserId + File.separator;
        String downloadName = DateTimeUtils.format(new Date(), DateTimeUtils.YEAR_MONTH_DAY_HOUR_MINUTE_SECOND_SIMPLE);
        SysBackTask task = new SysBackTask();
        //新增后台任务表信息
        addTask(task, loginUserId, downloadName, threadKey);
        ArrayList<Integer> list = new ArrayList<Integer>(groupIdSet);
        int size = list.size();
        //取余数,即第一次 查询的数量
        int rs = size % EXPORTVEHICLE_LIMIT;
        int fromIndex = 0;
        int toIndex = rs ;
        int count = 1;
        File file = null;
        InputStream in = null;
        DefaultExcelReportGenerator g = null;
        for(; toIndex<= size;) {
            if(!TraceController.ASYNCMAP.containsKey(task.getThreadKey())){
                cancleFlag = true;
                LOG.error("车辆预警查询导出任务被人为中断");
                break;
            }
            List<Integer> deviceIdList = list.subList(fromIndex, toIndex);
            // 2.然后走另外数据源查询硬件报警表信息
            List<AlarmInfo> infoList = alarmMapper.getAlarmInfo(queryParam, deviceIdList);
           if (CollectionUtils.isNotEmpty(infoList)) {
               infoList = paramTransport(infoList);
               if(fromIndex>=rs && null != file) {
                   try {
                       //追加数据
                       DownloadHelper.appendExcel3(file,infoList,g);
                   } catch (Exception e) {
                       LOG.error("导出失败", e);
                       task.setTaskStatus(BackTaskService.taskStatus_fail);
                       String tempstr = "文件生成异常！" + e.getMessage();
                       task.setMemo(StringTools.subStringMaxLength(tempstr, 100));
                       task.setTaskStatus(BackTaskService.taskStatus_interrupt);
                       Date tempDate = new Date();
                       task.setEndTime(tempDate);
                       task.setUpdateTime(tempDate);
                       backTaskService.updateBackTask4Propagation_REQUIRES_NEW(task);
                       return  false;
                   }
               }else {
                   try {
                       //先生成文件
                       DownloadHelper.downloadExcelReportTwo(Constant.HARD_ALARM_TEMPLATE_NAME, infoList,
                               holder, downloadName, Constant.FILE_TYPE_XLSX,tempPath);
                       file = new File(tempPath + File.separator + downloadName + Constant.FILE_TYPE_XLSX);
                       in = new FileInputStream(file);
                       g = new DefaultExcelReportGenerator(in, Constant.FILE_TYPE_XLSX);
                   } catch (Exception e) {
                       System.out.println(e);
                       task.setTaskStatus(BackTaskService.taskStatus_fail);
                       String tempstr = "文件生成异常！" + e.getMessage();
                       task.setMemo(StringTools.subStringMaxLength(tempstr, 100));
                       task.setTaskStatus(BackTaskService.taskStatus_interrupt);
                       Date tempDate = new Date();
                       task.setEndTime(tempDate);
                       task.setUpdateTime(tempDate);
                       backTaskService.updateBackTask4Propagation_REQUIRES_NEW(task);
                       return  false;
                   }
                   infoList.clear();
               }
           }
            fromIndex = toIndex;
            toIndex = toIndex+EXPORTVEHICLE_LIMIT;
            LOG.info("当前是第{}"+count+"次");
            count++;
        }
        try {
            in.close();
        } catch (Exception e) {
            e.printStackTrace();
            LOG.error("导出失败,输入流关闭异常", e);
            task.setTaskStatus(BackTaskService.taskStatus_interrupt);
            backTaskService.updateBackTask4Propagation_REQUIRES_NEW(task);
            return  false;
        }
        if(cancleFlag){
            task.setTaskStatus(BackTaskService.taskStatus_interrupt);
            Date tempDate = new Date();
            task.setEndTime(tempDate);
            task.setUpdateTime(tempDate);
            backTaskService.updateBackTask4Propagation_REQUIRES_NEW(task);
            LOG.debug("车辆预警查询被中断");
            return false;
        }
        LOG.info("车辆预警查询导出文件生成：" + downloadName);
        if(BackTaskService.taskStatus_fail != task.getTaskStatus()){
            task.setTaskStatus(BackTaskService.taskStatus_success);
            task.setSuccessCnt(1);
            String base64Url = EncryptionUtils.encrytBase64(downloadName + Constant.FILE_TYPE_XLSX);
            task.setDirName(base64Url);//临时存放，用来下载的base64码
            Date tempDate = new Date();
            task.setEndTime(tempDate);
            task.setUpdateTime(tempDate);
            backTaskService.updateBackTask4Propagation_REQUIRES_NEW(task);
        }
        return  true;
    }

    private void addTask(SysBackTask task, int loginUserId, String downloadName, String threadKey) {
        Date currentDate = new Date();
        task.setSuccessCnt(0);
        task.setTaskName("车辆预警查询导出");
        task.setStartTime(currentDate);
        task.setTotalCnt(1);
        task.setTaskStatus(BackTaskService.taskStatus_start);
        task.setCreateTime(currentDate);
        task.setCreateUser(loginUserId);
        task.setUpdateTime(currentDate);
        task.setUpdateUser(loginUserId);
        task.setThreadKey(threadKey);
        task.setSuccessCnt(0);
        task.setFileName(downloadName);
        backTaskService.insertBackTask4Propagation_REQUIRES_NEW(task);
    }
}
```



